# 개방패쇄원칙(OCP: Open Closed Principle)

확장에는 열려있고 변경에는 닫혀있어야 한다.

행위를 확장하는건 되지만 산출물이 변경되지 않게 설계하라는 뜻이다.

아키텍쳐를 공부하는 가장 근본적인 이유이다.

OCP가 지켜지지 않는다면 요구사항이 살짝 변경되었는데 소프트웨어를 갈아엎어야 될 수도 있다.

언제 어떻게 왜 발생하는지에 따라 기능과 책임을 분리하고, 계층구조로 조직화한다.

저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

구현방법은 처리 과정을 클래스 단위로 분할하고, 클래스는 컴포넌트 단위로 구분해서 구현한다.


말이 어렵지만

spring을 해봤거나 layered architecture에 대해 고민해봤다면 답을 얻을 수 있다.

표현계층(@Controller), 유스케이스(@Service) 계층 등으로 나누는건 컴포넌트를 나눈것이고(3 tier가 아닌 추가 컴포넌트가 있을시 @Componet를 활용 괜히 어노테이션 이름이 component가 아니다)

도메인별로 나눈것을 처리과정을 기능 단위로 나눠 책임을 분리시켰다고 생각할 수 있다.

또한 인터페이스는 열려있고, 구현체는 닫혀있다는것이 핵심이다.

아키텍쳐의 기본은 구현체에 의존하지 않는것에서 시작된다.

spring은 알아서 DI 와 IOC를 적용해주므로 아무 느낌이 없을 수도 있지만

spring은 태어날때부터 구현체에 의존하지 않게 만들어져있다.(@Service계층, @Repository 계층 등 @Component들은 이미 인터페이스로 열려있다.)

spring처럼 block된 구조의 프레임워크를 사용하지 않는다면 Layered Architecture를 적용하여 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호하자.